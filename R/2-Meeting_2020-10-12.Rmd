---
title: "Meeting-2020-10-12"
author: "Andre Luiz Cunha"
date: "`r Sys.Date()`"
output:
    html_document:
      number_section : true

params:
  year : 2019

---

```{r setup, include=FALSE}
library(lubridate)
library(ggplot2)
library(dplyr)
library(tidyr)
library(leaflet)
library(gstat)
library(sf)
library(sp)
library(osmdata)

knitr::opts_chunk$set(fig.width = 10, fig.height = 6, fig.path = "Figs/",
                      echo = TRUE)
```

# Dataset
The dataset was obtained at [City of Melbourne - Pedestrian Counting System](http://www.pedestrian.melbourne.vic.gov.au/). The data is from pedestrian counting system (loop sensor) and it contains hourly counts from 2009 to 2019. The main idea is to explore these data and figure out some spatio-temporal relationship between sensors, and detect events automatically.


```{r load_data, include=TRUE}
ped.year <- readRDS("../data/pedyear.RDS")
ped.summary <- readRDS("../data/pedsummary.RDS")

```

In this example was used only the year of 2019, and the following map show the sensors location and the their mean observed flow.

```{r map}

leaflet(data=ped.summary) %>% 
  fitBounds(~min(long), ~min(lat), ~max(long), ~max(lat)) %>%
  addCircleMarkers(lng=~long, lat=~lat, radius = ~sqrt(count.avg)/3, label = ~sensorID) %>% 
  # addProviderTiles(providers$Stamen.Toner)
  # addProviderTiles(providers$Esri.NatGeoWorldMap)
  addProviderTiles(providers$CartoDB.Positron)
  
```

# Exploratory Data Analysis
```{r ead-data}
## Formatting dataset
sensors <- ped.year %>%
  select(sensorID, lat, long, count, datetime) %>% 
  mutate(year=year(datetime),
         month=month(datetime, label=TRUE, abbr=TRUE),
         #wday=weekdays(datetime, abbreviate=TRUE),
         wday=factor(weekdays(datetime, abbreviate=TRUE),levels = c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")),
         hour=hour(datetime))

night.event <- sensors %>% filter(datetime >= "2019-08-22" & datetime < "2019-08-25")

night.before <- sensors %>% 
  filter(datetime >= ymd("2019-08-22") - weeks(4) & datetime < "2019-08-22" &
           wday %in% c("Thu", "Fri", "Sat")) %>% 
  group_by(sensorID, wday, hour) %>% 
  summarise(count.avg=mean(count))

```


## Weekdays pattern
It is important to characterize the weekdays pattern and the hourly distribution over the sensors, and months. The method proposed is robust to works even with this differences. 

I figured out that the "factor" level was wrong for the weekday variables.

```{r weekdays}
## Plot base
p <- ggplot(sensors %>% filter(sensorID == 1), 
            aes(x=hour, y=count, group=date(datetime), color=wday)) +
  geom_line()

## Plot by weekdays
p + facet_wrap(~wday)

## Plot by month and weekdays
p + facet_grid(rows=vars(month), col=vars(wday))

```

## White Night Case
```{r event-data}
## Event
ggplot(night.event, 
            aes(x=hour, y=count, group=sensorID, color=wday)) +
  geom_line() +
  facet_wrap(~date(datetime))

## 4-weeks before event
ggplot(night.before, 
            aes(x=hour, y=count.avg, group=sensorID, color=wday)) +
  geom_line() +
  facet_wrap(~wday)

```
Comparing the distribution between weekdays:
```{r dist-weekdays}
ggplot(night.event, aes(x=count)) +
  geom_histogram(aes(y=..density..), bins=20, color="black", fill="white") +
  geom_density(alpha=.2, fill="#FF7777") +
  facet_wrap(~wday)


ggplot(night.before, aes(x=count.avg)) +
  geom_histogram(aes(y=..density..), bins=20, color="black", fill="white") +
  geom_density(alpha=.2, fill="#FF7777") +
  facet_wrap(~wday)
  
```
```{r chi-test}
hist.event <- hist(night.event$count, breaks = seq(0,12000,by=500))
hist.4weeks <- hist(night.before$count.avg, breaks = seq(0,12000,by=500))
chisq.test(hist.event$counts, hist.4weeks$counts)
```


# Spatial Analysis
The packages [gstat](https://cran.r-project.org/web/packages/gstat/index.html) and [geoR](https://cran.r-project.org/web/packages/geoR/index.html) both compute the variogram in R. The gstat also considers spatio-temporal data.

Some useful tutorials:
- [brief tutorial in gstat](https://cran.r-project.org/web/packages/gstat/vignettes/gstat.pdf)
- [spatio-temporal geostatistics using gstat](https://cran.r-project.org/web/packages/gstat/vignettes/spatio-temporal-kriging.pdf)
- [notebook tutorial using gstat](https://github.com/GeostatsGuy/geostatsr/blob/master/kriging_demo_Rnotebook.ipynb)
- [tutorial in geoR](http://www.leg.ufpr.br/geoR/#introduction)

## Spatial dataset
```{r spatial-data, message=FALSE, warning=FALSE}
## Transform in spatial object (SP)
ped.sp <- ped.summary %>% rename(X=long, Y=lat)
## Attribute coordinates
coordinates(ped.sp) <- ~X+Y
## Attribute the projection WGS84 (4326)
proj4string(ped.sp) <- CRS("+init=epsg:4326")
## Convert to Australian projection
ped.sp <- spTransform(ped.sp, CRS("+init=epsg:7899"))
proj4string(ped.sp) <- as.character(NA)

## Spatial grid to feed kriging
x.range <- as.integer(range(ped.sp$X))
y.range <- as.integer(range(ped.sp$Y))
X <- seq(from=x.range[1]-100,to=x.range[2]+100, by=100)
Y <- seq(from=y.range[1]-100,to=y.range[2]+100, by=100)
coords.df <- crossing(X,Y)
## Transform it in SP class
coordinates(coords.df) <- ~X+Y
#proj4string(coords.df) <- proj4string(ped.sp)

## Plot the grid and known points
ggplot() +
  geom_point(data = as.data.frame(coords.df), aes(X,Y), shape=3) +
  geom_point(data = as.data.frame(ped.sp), aes(X,Y, color = "red", size = .5)) + coord_equal()
```
## Network data
```{r osmdata}
## Get Melbourne bounding box
lat.range <- range(ped.summary$lat)
lng.range <- range(ped.summary$long)
box <- c(lng.range[1],lat.range[1], lng.range[2], lat.range[2])
# box <- getbb("central Melbourne")
q <- opq(bbox=box) %>% 
  add_osm_feature(key='highway',
                  value=c('motorway', 'trunk', 'primary', 'secondary', 'tertiary', 'unclassified', 'residential', 'motorway_link', 'trunk_link', 'primary_link', 'secondary_link', 'tertiary_link')) %>%
  osmdata_sf()

ggplot() +
  geom_sf(data = q$osm_lines,
          inherit.aes = FALSE,
          color = "black",
          size = .4,
          alpha = .8)


## Real points to feed the variogram/krige
melba.sp <- q$osm_points$geometry
melba.sp <- st_transform(melba.sp, crs=CRS("+init=epsg:7899")) %>% 
  as_Spatial() %>% as.data.frame() %>% rename(X=coords.x1, Y=coords.x2)
coordinates(melba.sp) <- ~X+Y
# proj4string(melba.sp) <- as.character(NA)

```

## Inverse Distance
The very simple spatial estimation method:
$$ z^*(\bf{u}_{0}) = \sum^{n}_{\alpha=1} \frac{1}{d^{p}} z(\bf{u}_{\alpha}) $$

```{r invdist, warning=FALSE}
ped.idw <- idw(formula = count.avg~1, 
               idp = 2.0, 
               locations = ped.sp, 
               # newdata = melba.sp)
               newdata = coords.df)

ggplot() +
  geom_tile(data=as.data.frame(ped.idw), aes(x=X,y=Y, fill=var1.pred)) +
  geom_point(data=as.data.frame(ped.sp), aes(x=X, y=Y)) +
  coord_equal() +
  scale_fill_gradientn(colors=terrain.colors(10)) +
  theme_bw()
```



## Variogram

```{r variogram}
ped.vgm <- variogram(log(count.avg)~sqrt(X^2+Y^2), ped.sp, cutoff = 2400, width=100, alpha=c(0, 45, 90, 135), tol.hor=22.5, cressie=FALSE)
#print(ped.vgm)
  
## There are four models to calibrate the variogram: Sph, Exp, Gau, Mat
## The parameters psill, range and nugget will be estimated. It is a good practice to set up a guess. If there are no guesses, use NA in each parameter.
ped.fit <-fit.variogram(ped.vgm, model=vgm(psill = 1, model = "Exp", range = 100))
print(ped.fit)
plot(ped.vgm, ped.fit)
```
## Spatio-Temporal Variogram
```{r variogramST}

```


## Kriging

```{r kriging}
# Create any model to predict the values
#ped.vm.ani <- vgm(psill=1, model="Gau", range=100, nugget = 0, anis = c(0,.25))
ped.fit <-fit.variogram(ped.vgm, model=vgm(psill = 1, model = "Exp", range = 100))
plot(ped.vgm, ped.fit)
ped.krige <- krige(formula = count.avg~sqrt(X^2+Y^2),
                   locations = ped.sp,
                   newdata = coords.df,
                   model = ped.fit)

ggplot() +
  geom_tile(data=as.data.frame(ped.krige), aes(x=X,y=Y, fill=var1.pred)) +
  geom_point(data=as.data.frame(ped.sp), aes(x=X, y=Y)) +
  coord_equal() +
  scale_fill_gradientn(colors=terrain.colors(10)) +
  theme_bw()
```

