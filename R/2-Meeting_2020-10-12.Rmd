---
title: "Meeting-2020-10-12"
author: "Andre Luiz Cunha"
date: "`r Sys.Date()`"
output:
    html_document:
    number_section : true

params:
  year : 2019

---

```{r setup, include=FALSE}
library(lubridate)
library(ggplot2)
library(dplyr)
library(tidyr)
library(leaflet)
library(gstat)

knitr::opts_chunk$set(fig.width = 12, fig.height = 8, fig.path = "Figs/",
                      echo = TRUE)
```

# Dataset
The dataset was obtained at [City of Melbourne - Pedestrian Counting System](http://www.pedestrian.melbourne.vic.gov.au/). The data is from pedestrian counting system (loop sensor) and it contains hourly counts from 2009 to 2019. The main idea is to explore these data and figure out some spatio-temporal relationship between sensors, and detect events automatically.


```{r load_data, include=TRUE}
ped.year <- readRDS("../data/pedyear.RDS")
ped.summary <- readRDS("../data/pedsummary.RDS")

```

In this example was used only the year of 2019, and the following map show the sensors location and the their mean observed flow.

```{r map}

leaflet(data=ped.summary) %>% 
  fitBounds(~min(long), ~min(lat), ~max(long), ~max(lat)) %>%
  addCircleMarkers(lng=~long, lat=~lat, radius = ~sqrt(count.avg)/3, label = ~sensorID) %>% 
  # addProviderTiles(providers$Stamen.Toner)
  # addProviderTiles(providers$Esri.NatGeoWorldMap)
  addProviderTiles(providers$CartoDB.Positron)
  
```

# Exploratory Data Analysis
```{r ead-data}
## Formatting dataset
sensors <- ped.year %>%
  select(sensorID, lat, long, count, datetime) %>% 
  mutate(year=year(datetime),
         month=month(datetime, label=TRUE, abbr=TRUE),
         #wday=weekdays(datetime, abbreviate=TRUE),
         wday=factor(weekdays(datetime, abbreviate=TRUE),levels = c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")),
         hour=hour(datetime))

night.event <- sensors %>% filter(datetime >= "2019-08-22" & datetime < "2019-08-25")

night.before <- sensors %>% filter(datetime >= ymd("2019-08-22") - weeks(4) & datetime < "2019-08-22" & wday %in% c("Thu", "Fri", "Sat")) %>% 
  group_by(sensorID, wday, hour) %>% 
  summarise(count.avg=mean(count))

```


## Weekdays pattern
It is important to characterize the weekdays pattern and the hourly distribution over the sensors, and months. The method proposed is robust to works even with this differences. 

I figured out that the "factor" level was wrong for the weekday variables.

```{r weekdays}
## Plot base
p <- ggplot(sensors %>% filter(sensorID == 40), 
            aes(x=hour, y=count, group=date(datetime), color=wday)) +
  geom_line()

## Plot by weekdays
p + facet_wrap(~wday)

## Plot by month and weekdays
p + facet_grid(rows=vars(month), col=vars(wday))

```

## White Night Case
```{r event-data}
## Event
ggplot(night.event, 
            aes(x=hour, y=count, group=sensorID, color=wday)) +
  geom_line() +
  facet_wrap(~date(datetime))

## 4-weeks before event
ggplot(night.before, 
            aes(x=hour, y=count.avg, group=sensorID, color=wday)) +
  geom_line() +
  facet_wrap(~wday)

```
Comparing the distribution between weekdays:
```{r dist-weekdays}
ggplot(night.event, aes(x=count)) +
  geom_histogram(aes(y=..density..), bins=20, color="black", fill="white") +
  geom_density(alpha=.2, fill="#FF7777") +
  facet_wrap(~wday)


ggplot(night.before, aes(x=count.avg)) +
  geom_histogram(aes(y=..density..), bins=20, color="black", fill="white") +
  geom_density(alpha=.2, fill="#FF7777") +
  facet_wrap(~wday)
  
```
# Spatial Analysis

## Variogram

```{r variogram}
hist.event <- hist(night.event$count, breaks = seq(0,12000,by=500))
hist.4weeks <- hist(night.before$count.avg, breaks = seq(0,12000,by=500))
chisq.test(hist.event$counts, hist.4weeks$counts)
```

## Kriging
```{r kriging}

```

